import type { CategoryNode } from '@/utils/parseExcel';
import { db } from '@/db/drizzle';
import { categories, products } from '@/schema';

type ProductInput = {
  name: string;
  description: string;
  price: string;
  unit: string;
  sku: string;
  quantity: number;
  categoryId: number | null;
};

type FlatCategory = {
  name: string;
  parentName: string | null;
  tempId: string;
  parentTempId: string | null;
};

export async function importFullCatalog(tree: CategoryNode) {
  console.log('‚è≥ –£–¥–∞–ª–µ–Ω–∏–µ –≤—Å–µ—Ö –ø—Ä–æ–¥—É–∫—Ç–æ–≤ –∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–π...');
  await db.delete(products);
  await db.delete(categories);
  console.log('‚úÖ –û—á–∏—Å—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –ù–∞—á–∏–Ω–∞—é –∏–º–ø–æ—Ä—Ç...');

  const allCategories: FlatCategory[] = [];
  const allProducts: ProductInput[] = [];

  collectData(tree, null, allCategories, allProducts);

  console.log(`üìÅ –ö–∞—Ç–µ–≥–æ—Ä–∏–π –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏: ${allCategories.length}`);
  console.log(`üì¶ –¢–æ–≤–∞—Ä–æ–≤ –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏: ${allProducts.length}`);

  // –í—Å—Ç–∞–≤–ª—è–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–∞—á–∫–∞–º–∏ –∏ –ø–æ–ª—É—á–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ ID
  const categoryIdMap = new Map<string, number>();
  const chunkSize = 500;

  for (let i = 0; i < allCategories.length; i += chunkSize) {
    const chunk = allCategories.slice(i, i + chunkSize);

    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º tempId ‚Üí parentId –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–∞—Ä—Ç—ã
    const inserted = await Promise.all(
      chunk.map(async (cat) => {
        const parentId = cat.parentTempId
          ? (categoryIdMap.get(cat.parentTempId) ?? null)
          : null;

        const [insertedCategory] = await db
          .insert(categories)
          .values({
            name: cat.name,
            categoryId: parentId
          })
          .returning();

        if (insertedCategory) {
          categoryIdMap.set(cat.tempId, insertedCategory.id);
        }

        return insertedCategory;
      })
    );

    console.log(
      `‚úÖ –í—Å—Ç–∞–≤–ª–µ–Ω–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–π: ${i + inserted.length}/${allCategories.length}`
    );
  }

  // –ü–æ–¥–º–µ–Ω—è–µ–º categoryId —É –ø—Ä–æ–¥—É–∫—Ç–æ–≤ –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–π
  const preparedProducts = allProducts.map((p) => ({
    ...p,
    quantity: p.quantity.toString(), // –µ—Å–ª–∏ quantity ‚Äî —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –ø–æ–ª–µ
    categoryId:
      p.categoryId !== null
        ? (categoryIdMap.get(p.categoryId as any) ?? null)
        : null
  }));

  for (let i = 0; i < preparedProducts.length; i += chunkSize) {
    const chunk = preparedProducts.slice(i, i + chunkSize);
    await db.insert(products).values(chunk);
    console.log(
      `‚úÖ –í—Å—Ç–∞–≤–ª–µ–Ω–æ —Ç–æ–≤–∞—Ä–æ–≤: ${i + chunk.length}/${allProducts.length}`
    );
  }

  console.log('üéâ –ò–º–ø–æ—Ä—Ç –∑–∞–≤–µ—Ä—à—ë–Ω.');
}

function collectData(
  node: CategoryNode,
  parentTempId: string | null,
  categoriesList: FlatCategory[],
  productList: ProductInput[],
  depth: number = 0
): void {
  for (const [key, value] of Object.entries(node)) {
    if (key === '_products') {
      const prods = value as any[];

      for (const product of prods) {
        const quantityNumber =
          typeof product.quantity === 'string'
            ? parseFloat(product.quantity.replace(/,/g, ''))
            : product.quantity;

        productList.push({
          ...product,
          quantity: quantityNumber,
          categoryId: parentTempId // —ç—Ç–æ –±—É–¥–µ—Ç —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–æ –ø–æ—Ç–æ–º
        });
      }

      continue;
    }

    const tempId = `${key}_${depth}_${Math.random().toString(36).slice(2, 6)}`;
    categoriesList.push({
      name: key,
      parentName: parentTempId,
      tempId,
      parentTempId
    });

    collectData(
      value as CategoryNode,
      tempId,
      categoriesList,
      productList,
      depth + 1
    );
  }
}
